<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bantu Stream Connect - Home Feed</title>
    
    <!-- Preload critical resources -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Orbitron:wght@400;500;600;700&display=swap" rel="stylesheet" media="print" onload="this.media='all'">
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Supabase JS SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <!-- Performance Optimization: Critical CSS inlined -->
    <style>
        /* Color Theme - Same as pulse-feed.html and pulse-content-detail.html */
        :root {
            --deep-black: #0A0E12;
            --deep-navy: #0F172A;
            --soft-white: #F8FAFC;
            --slate-grey: #94A3B8;
            --bantu-blue: #1D4ED8;
            --warm-gold: #F59E0B;
            --error-color: #EF4444;
            --success-color: #10B981;
            --glow-cycle-1: #00A3FF;
            --glow-cycle-2: #0066FF;
            --glow-cycle-3: #8B5CF6;
            --glow-cycle-4: #EC4899;
            --card-bg: rgba(15, 23, 42, 0.6);
            --card-border: rgba(148, 163, 184, 0.2);
            --hover-overlay: rgba(255, 255, 255, 0.05);
            --active-overlay: rgba(245, 158, 11, 0.1);
            --indigo: #4F46E5;
            --gold-glow: rgba(245, 158, 11, 0.3);
            --blue-glow: rgba(29, 78, 216, 0.3);
            --notification-dot: #EF4444;
        }
        
        /* Light Theme Variables */
        .theme-light {
            --deep-black: #F8FAFC;
            --deep-navy: #FFFFFF;
            --soft-white: #0F172A;
            --slate-grey: #64748B;
            --card-bg: rgba(255, 255, 255, 0.9);
            --card-border: rgba(100, 116, 139, 0.2);
            --hover-overlay: rgba(15, 23, 42, 0.05);
        }
        
        /* High Contrast Theme */
        .theme-high-contrast {
            --deep-black: #000000;
            --deep-navy: #111827;
            --soft-white: #FFFFFF;
            --slate-grey: #E5E7EB;
            --bantu-blue: #2563EB;
            --warm-gold: #D97706;
            --card-bg: rgba(17, 24, 39, 0.95);
            --card-border: #FFFFFF;
        }
        
        /* Reduced Motion */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        /* Critical CSS for FCP */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: var(--deep-black);
            color: var(--soft-white);
            min-height: 100vh;
            overflow-x: hidden;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--deep-black);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border-top-color: var(--bantu-blue);
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Main Container - Critical for layout */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px;
            position: relative;
            z-index: 2;
            padding-bottom: 100px;
        }
        
        /* Header - Critical */
        .header {
            background: rgba(10, 14, 18, 0.9);
            backdrop-filter: blur(20px);
            padding: 16px 20px;
            position: sticky;
            top: 0;
            z-index: 100;
            border-bottom: 1px solid var(--card-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        /* Animated Background - Deferred */
        .animated-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            overflow: hidden;
        }
        
        .glow-cycle {
            position: absolute;
            border-radius: 50%;
            filter: blur(60px);
            opacity: 0.1;
            animation: float 8s infinite ease-in-out;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-20px) scale(1.05); }
        }
    </style>
    
    <!-- Non-critical CSS deferred -->
    <link rel="stylesheet" href="data:text/css,/* Deferred styles will be loaded */" media="print" onload="this.media='all'" id="deferred-styles">
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading" class="loading-screen" role="alert" aria-live="assertive">
        <div class="spinner" aria-hidden="true"></div>
        <div id="loading-text">Loading Bantu Stream Connect...</div>
    </div>

    <!-- Accessibility Skip Link -->
    <a href="#main-content" class="skip-link" id="skip-link">Skip to main content</a>

    <!-- Animated Background -->
    <div class="animated-bg" aria-hidden="true">
        <div class="glow-cycle glow-1"></div>
        <div class="glow-cycle glow-2"></div>
        <div class="glow-cycle glow-3"></div>
        <div class="glow-cycle glow-4"></div>
    </div>

    <!-- Notifications Panel -->
    <div id="notifications-panel" class="notifications-panel" role="region" aria-label="Notifications">
        <div class="notifications-header">
            <h2>Notifications</h2>
            <button id="close-notifications" class="icon-btn" aria-label="Close notifications">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="notifications-list" id="notifications-list">
            <!-- Notifications will be loaded here -->
        </div>
        <div class="notifications-footer">
            <button id="mark-all-read" class="text-btn">Mark all as read</button>
            <button id="notification-settings" class="text-btn">Settings</button>
        </div>
    </div>

    <!-- Analytics Dashboard Modal -->
    <div id="analytics-modal" class="analytics-modal" role="dialog" aria-modal="true" aria-labelledby="analytics-title">
        <div class="analytics-content">
            <div class="analytics-header">
                <h2 id="analytics-title">Analytics Dashboard</h2>
                <button id="close-analytics" class="close-btn" aria-label="Close analytics">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="analytics-body">
                <div class="analytics-grid">
                    <div class="analytics-card">
                        <h3>Watch Time</h3>
                        <div class="analytics-value" id="total-watch-time">0h 0m</div>
                        <div class="analytics-trend">+0% from last week</div>
                    </div>
                    <div class="analytics-card">
                        <h3>Sessions/User</h3>
                        <div class="analytics-value" id="sessions-per-user">0</div>
                        <div class="analytics-trend">+0% from last week</div>
                    </div>
                    <div class="analytics-card">
                        <h3>Return Rate</h3>
                        <div class="analytics-value" id="return-rate">0%</div>
                        <div class="analytics-trend">+0% from last week</div>
                    </div>
                    <div class="analytics-card">
                        <h3>Total Views</h3>
                        <div class="analytics-value" id="total-views">0</div>
                        <div class="analytics-trend">+0% from last week</div>
                    </div>
                </div>
                <div class="charts-container">
                    <canvas id="engagement-chart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- Theme Selector -->
    <div id="theme-selector" class="theme-selector" role="menu" aria-label="Theme selection">
        <button class="theme-option active" data-theme="dark" aria-label="Dark theme" role="menuitemradio" aria-checked="true">
            <i class="fas fa-moon"></i> Dark
        </button>
        <button class="theme-option" data-theme="light" aria-label="Light theme" role="menuitemradio" aria-checked="false">
            <i class="fas fa-sun"></i> Light
        </button>
        <button class="theme-option" data-theme="high-contrast" aria-label="High contrast theme" role="menuitemradio" aria-checked="false">
            <i class="fas fa-eye"></i> High Contrast
        </button>
    </div>

    <!-- Search Modal -->
    <div id="search-modal" class="search-modal" role="dialog" aria-modal="true" aria-labelledby="search-title">
        <div class="search-modal-header">
            <div class="search-input-container">
                <i class="search-icon fas fa-search" aria-hidden="true"></i>
                <input type="text" id="search-input" class="search-input" 
                       placeholder="Search for content, creators, or categories..." 
                       autocomplete="off"
                       aria-label="Search content">
            </div>
            <button id="close-search-btn" class="close-search-btn" aria-label="Close search">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="search-filters">
            <div class="filter-group">
                <label class="filter-label" for="category-filter">Category</label>
                <select id="category-filter" class="filter-select" aria-label="Filter by category">
                    <option value="">All Categories</option>
                    <option value="Movies">Movies</option>
                    <option value="TV Shows">TV Shows</option>
                    <option value="Documentaries">Documentaries</option>
                    <option value="Music">Music</option>
                    <option value="Sports">Sports</option>
                    <option value="News">News</option>
                    <option value="STEM">STEM</option>
                    <option value="Podcasts">Podcasts</option>
                </select>
            </div>
            <div class="filter-group">
                <label class="filter-label" for="media-type-filter">Media Type</label>
                <select id="media-type-filter" class="filter-select" aria-label="Filter by media type">
                    <option value="">All Types</option>
                    <option value="video">Video</option>
                    <option value="audio">Audio</option>
                    <option value="image">Image</option>
                </select>
            </div>
            <div class="filter-group">
                <label class="filter-label" for="sort-filter">Sort By</label>
                <select id="sort-filter" class="filter-select" aria-label="Sort results by">
                    <option value="newest">Newest First</option>
                    <option value="oldest">Oldest First</option>
                    <option value="popular">Most Popular</option>
                    <option value="trending">Trending</option>
                </select>
            </div>
        </div>
        <div id="search-results" class="search-results">
            <div id="search-results-grid" class="search-results-grid">
                <!-- Search results will be loaded here -->
            </div>
        </div>
    </div>

    <!-- Keyboard Shortcuts Help Modal -->
    <div id="keyboard-shortcuts-help" class="keyboard-shortcuts-help" role="dialog" aria-modal="true" aria-labelledby="shortcuts-title">
        <div class="shortcuts-header">
            <h2 id="shortcuts-title" class="shortcuts-title">Keyboard Shortcuts</h2>
            <button id="close-shortcuts-btn" class="close-search-btn" aria-label="Close shortcuts help">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="shortcuts-list">
            <div class="shortcut-item">
                <span>Search</span>
                <kbd class="shortcut-key">Ctrl + K</kbd>
            </div>
            <div class="shortcut-item">
                <span>Close Search/Modal</span>
                <kbd class="shortcut-key">Esc</kbd>
            </div>
            <div class="shortcut-item">
                <span>Play/Pause Video Preview</span>
                <kbd class="shortcut-key">Space</kbd>
            </div>
            <div class="shortcut-item">
                <span>Show Keyboard Shortcuts</span>
                <kbd class="shortcut-key">?</kbd>
            </div>
            <div class="shortcut-item">
                <span>Toggle Theme</span>
                <kbd class="shortcut-key">Alt + T</kbd>
            </div>
            <div class="shortcut-item">
                <span>Notifications</span>
                <kbd class="shortcut-key">Alt + N</kbd>
            </div>
            <div class="shortcut-item">
                <span>Analytics</span>
                <kbd class="shortcut-key">Alt + A</kbd>
            </div>
            <div class="shortcut-item">
                <span>Navigate to Home</span>
                <kbd class="shortcut-key">Alt + H</kbd>
            </div>
            <div class="shortcut-item">
                <span>Navigate to Profile</span>
                <kbd class="shortcut-key">Alt + P</kbd>
            </div>
            <div class="shortcut-item">
                <span>Refresh Content</span>
                <kbd class="shortcut-key">Ctrl + R</kbd>
            </div>
        </div>
    </div>

    <!-- Error Recovery Modal -->
    <div id="error-recovery-modal" class="error-recovery-modal" role="alertdialog" aria-labelledby="error-recovery-title" aria-modal="true">
        <div class="error-recovery-content">
            <h2 id="error-recovery-title">Connection Issue Detected</h2>
            <p id="error-recovery-message">We're having trouble connecting to the server. You can continue using cached content.</p>
            <div class="error-recovery-actions">
                <button id="retry-connection" class="btn-primary">Retry Connection</button>
                <button id="continue-offline" class="btn-secondary">Continue Offline</button>
                <button id="report-issue" class="btn-text">Report Issue</button>
            </div>
        </div>
    </div>

    <!-- Main Content (hidden until loaded) -->
    <div id="app" style="display: none;" aria-hidden="true">
        <!-- Header -->
        <header class="header">
            <div class="logo" onclick="window.location.href='index.html'" role="button" tabindex="0" aria-label="Bantu Stream Connect Home">
                <div class="logo-icon" aria-hidden="true">
                    <svg width="40" height="40" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <rect width="40" height="40" rx="8" fill="#0F172A"/>
                        <path d="M8 20 L12 16 L16 22 L20 18 L24 24 L28 20 L32 26" stroke="url(#pulse-gradient)" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
                        <circle cx="32" cy="26" r="3" fill="#F59E0B"/>
                        <defs>
                            <linearGradient id="pulse-gradient" x1="8" y1="20" x2="32" y2="26" gradientUnits="userSpaceOnUse">
                                <stop stop-color="#1D4ED8"/>
                                <stop offset="1" stop-color="#F59E0B"/>
                            </linearGradient>
                        </defs>
                    </svg>
                </div>
                <div class="logo-text">BANTU STREAM CONNECT</div>
            </div>
            <div class="header-actions">
                <!-- Theme Toggle -->
                <button id="theme-toggle" class="icon-btn" aria-label="Change theme" title="Change theme (Alt+T)">
                    <i class="fas fa-palette"></i>
                </button>
                
                <!-- Analytics Button -->
                <button id="analytics-btn" class="icon-btn" aria-label="View analytics" title="Analytics (Alt+A)">
                    <i class="fas fa-chart-line"></i>
                </button>
                
                <!-- Notifications Button -->
                <button id="notifications-btn" class="icon-btn" aria-label="Notifications" title="Notifications (Alt+N)">
                    <i class="fas fa-bell"></i>
                    <span class="notification-badge" id="notification-count" aria-hidden="true">0</span>
                </button>
                
                <!-- Search Button -->
                <button id="search-btn" class="icon-btn search-btn" aria-label="Search" title="Search (Ctrl+K)">
                    <i class="fas fa-search"></i>
                </button>
                
                <!-- Profile Button -->
                <button id="profile-btn" class="profile-btn" aria-label="Profile" title="Profile (Alt+P)">
                    <div class="profile-placeholder">
                        <i class="fas fa-user"></i>
                    </div>
                </button>
            </div>
        </header>

        <!-- Main Content -->
        <main id="main-content" class="container" tabindex="-1">
            <!-- Home-Feed Development Window - ALWAYS VISIBLE -->
            <div id="development-status-card" class="development-card" role="region" aria-label="Development Status">
                <div class="development-header">
                    <div class="pulse-icon-container" id="pulse-icon-container" 
                         onclick="window.location.href='pulse-feed.html'" 
                         role="button" tabindex="0" 
                         aria-label="Go to Pulse Feed">
                        <div class="pulse-icon" aria-hidden="true">
                            <svg viewBox="0 0 100 100">
                                <defs>
                                    <linearGradient id="pulseGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                                        <stop offset="0%" stop-color="#1D4ED8" />
                                        <stop offset="100%" stop-color="#F59E0B" />
                                    </linearGradient>
                                </defs>
                                <path class="pulse-path" d="M20,50 C30,20 40,30 50,50 S70,80 80,50" />
                                <circle class="pulse-node" cx="80" cy="50" r="4" />
                            </svg>
                        </div>
                        <div class="pulse-ripple" aria-hidden="true"></div>
                    </div>
                    
                    <div class="development-content">
                        <h2>We're Building Something Powerful</h2>
                        <div class="development-message">
                            Bantu Stream Connect is currently in active development.<br><br>
                            Our web experience is taking shape, and our mobile app is in its final stages ‚Äî preparing for public launch following our closed testing period on Google Play.<br><br>
                            While we build, you can explore what's already live:<br>
                            <strong>Bantu Connect Pulse</strong> ‚Äî a new space to share moments, ideas, and creativity.
                        </div>
                        <div class="cta-hint">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M5 12h14M12 5l7 7-7 7"/>
                            </svg>
                            Tap the pulsing icon to begin your journey to Pulse Feed
                        </div>
                    </div>
                </div>
            </div>

            <!-- Hero Section -->
            <section class="hero" aria-labelledby="hero-title">
                <h1 id="hero-title">Welcome to Bantu Stream Connect</h1>
                <p>Discover amazing content from creators across Africa</p>
                <button id="browse-all-btn" class="hero-btn" data-target="explore">Browse All Content</button>
            </section>

            <!-- Content Sections -->
            <div id="content-sections">
                <!-- Content will be loaded here -->
            </div>

            <!-- Performance Metrics Display (Hidden by default) -->
            <div id="performance-metrics" class="performance-metrics" aria-live="polite" aria-label="Performance metrics">
                <div class="metric">
                    <span class="metric-label">FCP:</span>
                    <span class="metric-value" id="fcp-metric">0s</span>
                </div>
                <div class="metric">
                    <span class="metric-label">LCP:</span>
                    <span class="metric-value" id="lcp-metric">0s</span>
                </div>
                <div class="metric">
                    <span class="metric-label">CLS:</span>
                    <span class="metric-value" id="cls-metric">0</span>
                </div>
            </div>

            <!-- Infinite Scroll Loading Indicator -->
            <div id="infinite-scroll-loading" class="infinite-scroll-loading" style="display: none;" aria-live="polite" aria-label="Loading more content">
                <div class="infinite-scroll-spinner" aria-hidden="true"></div>
                <div>Loading more content...</div>
            </div>

            <!-- Browse All CTA -->
            <div class="browse-all-cta">
                <button id="browse-all-cta" class="cta-button" data-target="content-library" aria-label="Browse all content">
                    <i class="fas fa-compass" aria-hidden="true"></i>
                    Browse All Content
                    <i class="fas fa-arrow-right" aria-hidden="true"></i>
                </button>
            </div>
        </main>

        <!-- Footer -->
        <footer class="footer" role="contentinfo">
            <p>Bantu Stream Connect ¬© 2025 ‚Ä¢ Built in South Africa</p>
            <div class="footer-links">
                <a href="data-deletion-request.html" aria-label="Data deletion request">Data Deletion Request</a>
                <a href="delete-account.html" aria-label="Delete account">Delete Account</a>
                <a href="empowerment.html" aria-label="Empowerment">Empowerment</a>
                <a href="blog.html" aria-label="Blog">Blog</a>
                <a href="privacy-policy.html" aria-label="Privacy policy">Privacy Policy</a>
                <a href="thank-you.html" aria-label="Thank you">Thank You</a>
                <a href="accessibility.html" aria-label="Accessibility statement">Accessibility</a>
            </div>
            <div class="footer-contact">
                Need help? Contact us at <a href="mailto:support@bantustreamconnect.com">support@bantustreamconnect.com</a>
            </div>
            <div class="performance-info">
                <button id="toggle-performance" class="text-btn" aria-label="Toggle performance metrics">
                    <i class="fas fa-tachometer-alt"></i> Performance
                </button>
            </div>
        </footer>
    </div>

    <!-- Toast Container -->
    <div id="toast-container" role="region" aria-live="polite" aria-label="Notifications"></div>

    <!-- Cache Status Indicator -->
    <div id="cache-status" class="cache-status" aria-live="polite" aria-label="Cache status">
        <span id="cache-status-text">Cache: Loading...</span>
    </div>

    <!-- SIMPLE SUPABASE CLIENT FOR CONTENT QUERIES -->
    <script>
        // Enhanced Supabase client with caching and error recovery
        class EnhancedSupabaseClient {
            constructor(url, key) {
                this.url = url;
                this.key = key;
                this.cache = new Map();
                this.cacheTTL = 5 * 60 * 1000; // 5 minutes cache TTL
                this.retryCount = 0;
                this.maxRetries = 3;
                this.retryDelay = 1000;
            }
            
            async query(table, options = {}) {
                const {
                    select = '*',
                    where = {},
                    orderBy = 'created_at',
                    order = 'desc',
                    limit = 100,
                    offset = 0
                } = options;
                
                // Generate cache key
                const cacheKey = this.generateCacheKey(table, options);
                
                // Check cache first
                if (this.cache.has(cacheKey)) {
                    const cached = this.cache.get(cacheKey);
                    if (Date.now() - cached.timestamp < this.cacheTTL) {
                        console.log('‚úÖ Serving from cache:', cacheKey);
                        return cached.data;
                    }
                    this.cache.delete(cacheKey);
                }
                
                // Build query URL
                let queryUrl = `${this.url}/rest/v1/${table}?select=${select}`;
                
                // Add filters
                Object.keys(where).forEach(key => {
                    queryUrl += `&${key}=eq.${encodeURIComponent(where[key])}`;
                });
                
                // Add ordering
                if (orderBy) {
                    queryUrl += `&order=${orderBy}.${order}`;
                }
                
                // Add limit and offset
                queryUrl += `&limit=${limit}&offset=${offset}`;
                
                // Try to fetch with retry logic
                for (let attempt = 0; attempt <= this.maxRetries; attempt++) {
                    try {
                        const response = await fetch(queryUrl, {
                            headers: {
                                'apikey': this.key,
                                'Authorization': `Bearer ${this.key}`,
                                'Content-Type': 'application/json',
                                'Cache-Control': 'max-age=300' // 5 minutes cache
                            },
                            signal: AbortSignal.timeout(10000) // 10 second timeout
                        });
                        
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        const data = await response.json();
                        
                        // Store in cache
                        this.cache.set(cacheKey, {
                            data: data,
                            timestamp: Date.now()
                        });
                        
                        // Clear retry count on success
                        this.retryCount = 0;
                        
                        return data;
                        
                    } catch (error) {
                        console.error(`Supabase query attempt ${attempt + 1} failed:`, error);
                        
                        if (attempt === this.maxRetries) {
                            // Last attempt failed, try to serve from localStorage cache
                            const offlineCache = localStorage.getItem(`cache_${cacheKey}`);
                            if (offlineCache) {
                                const parsed = JSON.parse(offlineCache);
                                if (Date.now() - parsed.timestamp < this.cacheTTL * 2) {
                                    console.log('‚ö†Ô∏è Using offline cache:', cacheKey);
                                    return parsed.data;
                                }
                            }
                            
                            // If we have cached data from previous successful query, use it
                            const cached = this.cache.get(cacheKey);
                            if (cached) {
                                console.log('‚ö†Ô∏è Using stale cache:', cacheKey);
                                return cached.data;
                            }
                            
                            throw error;
                        }
                        
                        // Wait before retrying
                        await new Promise(resolve => 
                            setTimeout(resolve, this.retryDelay * Math.pow(2, attempt))
                        );
                    }
                }
            }
            
            generateCacheKey(table, options) {
                return `${table}_${JSON.stringify(options)}`;
            }
            
            clearCache() {
                this.cache.clear();
            }
            
            async preloadContent() {
                // Preload trending content
                try {
                    await this.query('Content', {
                        select: '*',
                        where: { status: 'published' },
                        orderBy: 'views',
                        order: 'desc',
                        limit: 10
                    });
                    console.log('‚úÖ Preloaded trending content');
                } catch (error) {
                    console.log('‚ö†Ô∏è Preloading failed, will load on demand');
                }
            }
        }
        
        // Initialize enhanced Supabase client
        const contentSupabase = new EnhancedSupabaseClient(
            'https://ydnxqnbjoshvxteevemc.supabase.co',
            'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlkbnhxbmJqb3Nodnh0ZWV2ZW1jIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2MzI0OTMsImV4cCI6MjA3MzIwODQ5M30.NlaCCnLPSz1mM7AFeSlfZQ78kYEKUMh_Fi-7P_ccs_U'
        );
        
        console.log('‚úÖ Enhanced Supabase client initialized with caching');
    </script>

    <!-- Main Application JavaScript -->
    <script>
        // Performance monitoring
        const PerformanceMonitor = {
            metrics: {
                fcp: 0,
                lcp: 0,
                cls: 0,
                fid: 0,
                ttfb: 0
            },
            
            init() {
                if ('PerformanceObserver' in window) {
                    this.setupObservers();
                    this.trackNavigation();
                    this.trackResourceLoading();
                }
                
                // Report metrics after page load
                window.addEventListener('load', () => {
                    setTimeout(() => this.reportMetrics(), 1000);
                });
            },
            
            setupObservers() {
                // FCP Observer
                try {
                    const fcpObserver = new PerformanceObserver((entryList) => {
                        const entries = entryList.getEntries();
                        const lastEntry = entries[entries.length - 1];
                        this.metrics.fcp = lastEntry.startTime;
                        this.updateMetricDisplay('fcp', this.metrics.fcp);
                    });
                    fcpObserver.observe({ entryTypes: ['paint'] });
                } catch (e) {}
                
                // LCP Observer
                try {
                    const lcpObserver = new PerformanceObserver((entryList) => {
                        const entries = entryList.getEntries();
                        const lastEntry = entries[entries.length - 1];
                        this.metrics.lcp = lastEntry.startTime;
                        this.updateMetricDisplay('lcp', this.metrics.lcp);
                    });
                    lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });
                } catch (e) {}
                
                // CLS Observer
                try {
                    const clsObserver = new PerformanceObserver((entryList) => {
                        for (const entry of entryList.getEntries()) {
                            this.metrics.cls += entry.value;
                        }
                        this.updateMetricDisplay('cls', this.metrics.cls);
                    });
                    clsObserver.observe({ entryTypes: ['layout-shift'] });
                } catch (e) {}
            },
            
            updateMetricDisplay(metric, value) {
                const element = document.getElementById(`${metric}-metric`);
                if (element) {
                    if (metric === 'cls') {
                        element.textContent = value.toFixed(3);
                    } else {
                        element.textContent = `${(value / 1000).toFixed(2)}s`;
                    }
                }
            },
            
            trackNavigation() {
                const timing = performance.timing;
                this.metrics.ttfb = timing.responseStart - timing.requestStart;
            },
            
            trackResourceLoading() {
                const resources = performance.getEntriesByType('resource');
                resources.forEach(resource => {
                    if (resource.initiatorType === 'img' || resource.initiatorType === 'video') {
                        console.log(`üì¶ ${resource.name} loaded in ${resource.duration.toFixed(0)}ms`);
                    }
                });
            },
            
            reportMetrics() {
                // Send to analytics
                if (window.analytics) {
                    window.analytics.track('performance_metrics', this.metrics);
                }
                
                // Check against targets
                if (this.metrics.fcp > 1500) {
                    console.warn(`‚ö†Ô∏è FCP ${this.metrics.fcp}ms exceeds target 1500ms`);
                }
                if (this.metrics.lcp > 2500) {
                    console.warn(`‚ö†Ô∏è LCP ${this.metrics.lcp}ms exceeds target 2500ms`);
                }
                if (this.metrics.cls > 0.1) {
                    console.warn(`‚ö†Ô∏è CLS ${this.metrics.cls} exceeds target 0.1`);
                }
            }
        };
        
        // Analytics System
        const AnalyticsSystem = {
            userId: null,
            sessionId: null,
            sessionStart: null,
            watchTime: 0,
            events: [],
            
            init() {
                this.userId = localStorage.getItem('analytics_user_id') || this.generateId();
                this.sessionId = this.generateId();
                this.sessionStart = Date.now();
                
                localStorage.setItem('analytics_user_id', this.userId);
                
                this.trackSessionStart();
                this.setupEventTracking();
                this.setupPerformanceTracking();
            },
            
            generateId() {
                return 'id_' + Math.random().toString(36).substr(2, 9);
            },
            
            track(event, properties = {}) {
                const eventData = {
                    event,
                    properties: {
                        ...properties,
                        userId: this.userId,
                        sessionId: this.sessionId,
                        timestamp: Date.now(),
                        page: window.location.pathname
                    }
                };
                
                this.events.push(eventData);
                
                // Send to Supabase if online
                if (navigator.onLine) {
                    this.sendToSupabase(eventData);
                } else {
                    // Store for later
                    this.queueEvent(eventData);
                }
                
                console.log(`üìä Tracked: ${event}`, eventData.properties);
            },
            
            async sendToSupabase(eventData) {
                try {
                    // This would send to your analytics table
                    // await supabaseAuth.from('analytics_events').insert(eventData);
                } catch (error) {
                    console.error('Failed to send analytics:', error);
                }
            },
            
            queueEvent(eventData) {
                const queued = JSON.parse(localStorage.getItem('analytics_queue') || '[]');
                queued.push(eventData);
                localStorage.setItem('analytics_queue', JSON.stringify(queued));
            },
            
            trackSessionStart() {
                this.track('session_start', {
                    session_start: this.sessionStart,
                    return_user: localStorage.getItem('last_session') ? true : false
                });
                
                localStorage.setItem('last_session', Date.now());
            },
            
            trackContentInteraction(contentId, type, details = {}) {
                this.track('content_interaction', {
                    content_id: contentId,
                    interaction_type: type,
                    ...details
                });
            },
            
            trackWatchTime(contentId, duration) {
                this.watchTime += duration;
                this.track('watch_time', {
                    content_id: contentId,
                    duration: duration,
                    total_watch_time: this.watchTime
                });
                
                // Update analytics display
                this.updateAnalyticsDisplay();
            },
            
            updateAnalyticsDisplay() {
                const hours = Math.floor(this.watchTime / 3600000);
                const minutes = Math.floor((this.watchTime % 3600000) / 60000);
                document.getElementById('total-watch-time').textContent = `${hours}h ${minutes}m`;
            },
            
            setupEventTracking() {
                // Track clicks
                document.addEventListener('click', (e) => {
                    const target = e.target;
                    if (target.closest('.content-card')) {
                        const card = target.closest('.content-card');
                        const contentId = card.dataset.contentId;
                        if (contentId) {
                            this.trackContentInteraction(contentId, 'card_click');
                        }
                    }
                });
                
                // Track video plays
                document.addEventListener('play', (e) => {
                    if (e.target.tagName === 'VIDEO') {
                        const video = e.target;
                        const contentId = video.closest('.content-card')?.dataset.contentId;
                        if (contentId) {
                            this.trackContentInteraction(contentId, 'video_play');
                        }
                    }
                }, true);
                
                // Track search
                const searchInput = document.getElementById('search-input');
                if (searchInput) {
                    searchInput.addEventListener('search', (e) => {
                        this.track('search', { query: e.target.value });
                    });
                }
            },
            
            setupPerformanceTracking() {
                window.addEventListener('load', () => {
                    const loadTime = Date.now() - this.sessionStart;
                    this.track('page_load', { load_time: loadTime });
                });
            },
            
            getEngagementMetrics() {
                return {
                    watch_time: this.watchTime,
                    sessions_per_user: this.getSessionsPerUser(),
                    return_rate: this.getReturnRate(),
                    total_views: this.getTotalViews()
                };
            },
            
            getSessionsPerUser() {
                const sessions = parseInt(localStorage.getItem('total_sessions') || '0');
                return sessions;
            },
            
            getReturnRate() {
                const totalSessions = parseInt(localStorage.getItem('total_sessions') || '0');
                const returnSessions = parseInt(localStorage.getItem('return_sessions') || '0');
                return totalSessions > 0 ? Math.round((returnSessions / totalSessions) * 100) : 0;
            },
            
            getTotalViews() {
                return parseInt(localStorage.getItem('total_views') || '0');
            }
        };
        
        // Real-time Notifications System
        const NotificationSystem = {
            notifications: [],
            unreadCount: 0,
            realtimeChannel: null,
            
            async init() {
                await this.loadNotifications();
                this.setupRealtime();
                this.renderNotifications();
                this.setupEventListeners();
            },
            
            async loadNotifications() {
                try {
                    // Load from localStorage
                    const saved = localStorage.getItem('notifications');
                    if (saved) {
                        this.notifications = JSON.parse(saved);
                        this.unreadCount = this.notifications.filter(n => !n.read).length;
                        this.updateBadge();
                    }
                    
                    // Fetch new notifications from server
                    if (navigator.onLine) {
                        await this.fetchNewNotifications();
                    }
                } catch (error) {
                    console.error('Failed to load notifications:', error);
                }
            },
            
            async fetchNewNotifications() {
                // This would fetch from your API
                // For now, simulate with mock data
                const mockNotifications = [
                    {
                        id: 1,
                        type: 'new_content',
                        title: 'New Content Available',
                        message: '5 new videos uploaded in your favorite categories',
                        timestamp: Date.now() - 3600000, // 1 hour ago
                        read: false,
                        icon: 'fas fa-video'
                    },
                    {
                        id: 2,
                        type: 'trending',
                        title: 'Content is Trending',
                        message: 'Your video "African Sunrise" is trending now!',
                        timestamp: Date.now() - 7200000, // 2 hours ago
                        read: false,
                        icon: 'fas fa-fire'
                    },
                    {
                        id: 3,
                        type: 'creator',
                        title: 'New Creator Alert',
                        message: 'Tech Africa just started following you',
                        timestamp: Date.now() - 10800000, // 3 hours ago
                        read: true,
                        icon: 'fas fa-user-plus'
                    }
                ];
                
                // Add new notifications
                mockNotifications.forEach(notification => {
                    if (!this.notifications.find(n => n.id === notification.id)) {
                        this.notifications.unshift(notification);
                    }
                });
                
                this.saveNotifications();
            },
            
            setupRealtime() {
                // Setup Supabase Realtime for notifications
                // This is a placeholder - implement with your real Supabase channel
                console.log('üì° Setting up real-time notifications...');
                
                // Simulate real-time updates
                setInterval(() => {
                    this.simulateRealtimeUpdate();
                }, 30000); // Every 30 seconds
            },
            
            simulateRealtimeUpdate() {
                if (Math.random() > 0.7) { // 30% chance of new notification
                    const newNotification = {
                        id: Date.now(),
                        type: 'realtime',
                        title: 'Live Update',
                        message: 'New content trending right now!',
                        timestamp: Date.now(),
                        read: false,
                        icon: 'fas fa-bolt'
                    };
                    
                    this.addNotification(newNotification);
                    this.showPushNotification(newNotification);
                }
            },
            
            addNotification(notification) {
                this.notifications.unshift(notification);
                if (!notification.read) {
                    this.unreadCount++;
                    this.updateBadge();
                }
                this.saveNotifications();
                this.renderNotifications();
            },
            
            markAsRead(id) {
                const notification = this.notifications.find(n => n.id === id);
                if (notification && !notification.read) {
                    notification.read = true;
                    this.unreadCount--;
                    this.updateBadge();
                    this.saveNotifications();
                    this.renderNotifications();
                }
            },
            
            markAllAsRead() {
                this.notifications.forEach(n => n.read = true);
                this.unreadCount = 0;
                this.updateBadge();
                this.saveNotifications();
                this.renderNotifications();
            },
            
            updateBadge() {
                const badge = document.getElementById('notification-count');
                if (badge) {
                    badge.textContent = this.unreadCount;
                    badge.style.display = this.unreadCount > 0 ? 'flex' : 'none';
                }
            },
            
            saveNotifications() {
                localStorage.setItem('notifications', JSON.stringify(this.notifications));
            },
            
            renderNotifications() {
                const container = document.getElementById('notifications-list');
                if (!container) return;
                
                if (this.notifications.length === 0) {
                    container.innerHTML = `
                        <div class="empty-notifications">
                            <i class="fas fa-bell-slash"></i>
                            <p>No notifications yet</p>
                        </div>
                    `;
                    return;
                }
                
                container.innerHTML = this.notifications.map(notification => `
                    <div class="notification-item ${notification.read ? 'read' : 'unread'}" 
                         data-id="${notification.id}"
                         role="button"
                         tabindex="0">
                        <div class="notification-icon">
                            <i class="${notification.icon}"></i>
                        </div>
                        <div class="notification-content">
                            <h4>${notification.title}</h4>
                            <p>${notification.message}</p>
                            <span class="notification-time">${this.formatTime(notification.timestamp)}</span>
                        </div>
                        ${!notification.read ? '<div class="notification-dot"></div>' : ''}
                    </div>
                `).join('');
                
                // Add click handlers
                container.querySelectorAll('.notification-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        const id = parseInt(item.dataset.id);
                        this.markAsRead(id);
                        
                        // Handle notification click action
                        this.handleNotificationAction(id);
                    });
                    
                    // Keyboard support
                    item.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            item.click();
                        }
                    });
                });
            },
            
            formatTime(timestamp) {
                const now = Date.now();
                const diff = now - timestamp;
                
                if (diff < 60000) return 'Just now';
                if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`;
                if (diff < 86400000) return `${Math.floor(diff / 3600000)}h ago`;
                return `${Math.floor(diff / 86400000)}d ago`;
            },
            
            showPushNotification(notification) {
                // Check if browser supports notifications
                if (!("Notification" in window)) return;
                
                // Check if permission is granted
                if (Notification.permission === "granted") {
                    this.createNotification(notification);
                } else if (Notification.permission !== "denied") {
                    Notification.requestPermission().then(permission => {
                        if (permission === "granted") {
                            this.createNotification(notification);
                        }
                    });
                }
            },
            
            createNotification(notification) {
                const options = {
                    body: notification.message,
                    icon: '/icon.png',
                    tag: 'bantu-notification'
                };
                
                const notif = new Notification(notification.title, options);
                
                notif.onclick = () => {
                    window.focus();
                    this.markAsRead(notification.id);
                    this.handleNotificationAction(notification.id);
                };
            },
            
            handleNotificationAction(id) {
                const notification = this.notifications.find(n => n.id === id);
                if (!notification) return;
                
                switch (notification.type) {
                    case 'trending':
                        window.location.href = 'trending_screen.html';
                        break;
                    case 'new_content':
                        // Refresh content
                        if (window.refreshContent) {
                            window.refreshContent();
                        }
                        break;
                }
            },
            
            setupEventListeners() {
                // Notifications button
                const notificationsBtn = document.getElementById('notifications-btn');
                const notificationsPanel = document.getElementById('notifications-panel');
                const closeNotifications = document.getElementById('close-notifications');
                const markAllRead = document.getElementById('mark-all-read');
                
                if (notificationsBtn && notificationsPanel) {
                    notificationsBtn.addEventListener('click', () => {
                        notificationsPanel.classList.toggle('active');
                        if (notificationsPanel.classList.contains('active')) {
                            // Mark all as read when opening
                            this.markAllAsRead();
                        }
                    });
                }
                
                if (closeNotifications) {
                    closeNotifications.addEventListener('click', () => {
                        notificationsPanel.classList.remove('active');
                    });
                }
                
                if (markAllRead) {
                    markAllRead.addEventListener('click', () => {
                        this.markAllAsRead();
                    });
                }
                
                // Close panel when clicking outside
                document.addEventListener('click', (e) => {
                    if (!notificationsPanel?.contains(e.target) && 
                        !notificationsBtn?.contains(e.target) &&
                        notificationsPanel?.classList.contains('active')) {
                        notificationsPanel.classList.remove('active');
                    }
                });
            }
        };
        
        // Theme System
        const ThemeSystem = {
            currentTheme: 'dark',
            
            init() {
                this.loadTheme();
                this.applyTheme();
                this.setupEventListeners();
                this.setupThemeSelector();
            },
            
            loadTheme() {
                const saved = localStorage.getItem('theme');
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                this.currentTheme = saved || (prefersDark ? 'dark' : 'light');
            },
            
            saveTheme() {
                localStorage.setItem('theme', this.currentTheme);
            },
            
            applyTheme() {
                document.body.className = `theme-${this.currentTheme}`;
                
                // Update meta theme-color
                const themeColor = this.getThemeColor();
                const metaThemeColor = document.querySelector('meta[name="theme-color"]');
                if (metaThemeColor) {
                    metaThemeColor.setAttribute('content', themeColor);
                } else {
                    const meta = document.createElement('meta');
                    meta.name = 'theme-color';
                    meta.content = themeColor;
                    document.head.appendChild(meta);
                }
                
                // Update theme selector
                this.updateThemeSelector();
            },
            
            getThemeColor() {
                switch(this.currentTheme) {
                    case 'light': return '#F8FAFC';
                    case 'high-contrast': return '#000000';
                    default: return '#0A0E12';
                }
            },
            
            setTheme(theme) {
                this.currentTheme = theme;
                this.saveTheme();
                this.applyTheme();
                
                // Track theme change
                if (window.analytics) {
                    window.analytics.track('theme_changed', { theme });
                }
            },
            
            setupEventListeners() {
                // Theme toggle button
                const themeToggle = document.getElementById('theme-toggle');
                if (themeToggle) {
                    themeToggle.addEventListener('click', () => {
                        const themes = ['dark', 'light', 'high-contrast'];
                        const currentIndex = themes.indexOf(this.currentTheme);
                        const nextIndex = (currentIndex + 1) % themes.length;
                        this.setTheme(themes[nextIndex]);
                    });
                }
                
                // Listen for system theme changes
                window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
                    if (!localStorage.getItem('theme')) {
                        this.setTheme(e.matches ? 'dark' : 'light');
                    }
                });
            },
            
            setupThemeSelector() {
                const selector = document.getElementById('theme-selector');
                if (!selector) return;
                
                // Create if doesn't exist
                if (!selector.innerHTML) {
                    selector.innerHTML = `
                        <button class="theme-option active" data-theme="dark" aria-label="Dark theme">
                            <i class="fas fa-moon"></i> Dark
                        </button>
                        <button class="theme-option" data-theme="light" aria-label="Light theme">
                            <i class="fas fa-sun"></i> Light
                        </button>
                        <button class="theme-option" data-theme="high-contrast" aria-label="High contrast theme">
                            <i class="fas fa-eye"></i> High Contrast
                        </button>
                    `;
                }
                
                // Add event listeners
                selector.querySelectorAll('.theme-option').forEach(option => {
                    option.addEventListener('click', () => {
                        const theme = option.dataset.theme;
                        this.setTheme(theme);
                    });
                });
                
                this.updateThemeSelector();
            },
            
            updateThemeSelector() {
                const selector = document.getElementById('theme-selector');
                if (!selector) return;
                
                selector.querySelectorAll('.theme-option').forEach(option => {
                    const isActive = option.dataset.theme === this.currentTheme;
                    option.classList.toggle('active', isActive);
                    option.setAttribute('aria-checked', isActive);
                });
            }
        };
        
        // Accessibility System
        const AccessibilitySystem = {
            init() {
                this.setupSkipLink();
                this.setupFocusManagement();
                this.setupKeyboardNavigation();
                this.setupAriaLabels();
                this.setupReducedMotion();
            },
            
            setupSkipLink() {
                const skipLink = document.getElementById('skip-link');
                if (skipLink) {
                    skipLink.addEventListener('click', (e) => {
                        e.preventDefault();
                        const mainContent = document.getElementById('main-content');
                        if (mainContent) {
                            mainContent.tabIndex = -1;
                            mainContent.focus();
                            setTimeout(() => {
                                mainContent.removeAttribute('tabindex');
                            }, 1000);
                        }
                    });
                }
            },
            
            setupFocusManagement() {
                // Trap focus in modals
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Tab') {
                        this.handleTabKey(e);
                    }
                });
                
                // Focus on notifications when they appear
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                            const target = mutation.target;
                            if (target.classList.contains('active') && 
                                (target.id === 'notifications-panel' || target.id === 'analytics-modal')) {
                                const firstFocusable = target.querySelector('button, input, [tabindex]:not([tabindex="-1"])');
                                if (firstFocusable) {
                                    setTimeout(() => firstFocusable.focus(), 100);
                                }
                            }
                        }
                    });
                });
                
                const notificationsPanel = document.getElementById('notifications-panel');
                const analyticsModal = document.getElementById('analytics-modal');
                if (notificationsPanel) observer.observe(notificationsPanel, { attributes: true });
                if (analyticsModal) observer.observe(analyticsModal, { attributes: true });
            },
            
            handleTabKey(e) {
                const modal = document.querySelector('.modal.active, .notifications-panel.active');
                if (!modal) return;
                
                const focusableElements = modal.querySelectorAll(
                    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
                );
                
                if (focusableElements.length === 0) return;
                
                const firstElement = focusableElements[0];
                const lastElement = focusableElements[focusableElements.length - 1];
                
                if (e.shiftKey) {
                    if (document.activeElement === firstElement) {
                        e.preventDefault();
                        lastElement.focus();
                    }
                } else {
                    if (document.activeElement === lastElement) {
                        e.preventDefault();
                        firstElement.focus();
                    }
                }
            },
            
            setupKeyboardNavigation() {
                // Enhanced keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Don't trigger if user is typing
                    if (e.target.tagName === 'INPUT' || 
                        e.target.tagName === 'TEXTAREA' || 
                        e.target.isContentEditable) {
                        return;
                    }
                    
                    // Alt+T for theme toggle
                    if (e.altKey && e.key === 't') {
                        e.preventDefault();
                        document.getElementById('theme-toggle')?.click();
                    }
                    
                    // Alt+N for notifications
                    if (e.altKey && e.key === 'n') {
                        e.preventDefault();
                        document.getElementById('notifications-btn')?.click();
                    }
                    
                    // Alt+A for analytics
                    if (e.altKey && e.key === 'a') {
                        e.preventDefault();
                        document.getElementById('analytics-btn')?.click();
                    }
                    
                    // Escape to close modals
                    if (e.key === 'Escape') {
                        this.closeAllModals();
                    }
                });
            },
            
            closeAllModals() {
                document.querySelectorAll('.modal.active, .notifications-panel.active').forEach(modal => {
                    modal.classList.remove('active');
                });
            },
            
            setupAriaLabels() {
                // Ensure all interactive elements have proper labels
                document.querySelectorAll('button:not([aria-label]), a:not([aria-label])').forEach(element => {
                    const text = element.textContent.trim();
                    if (text && !element.getAttribute('aria-label')) {
                        element.setAttribute('aria-label', text);
                    }
                });
                
                // Add role to content grids
                document.querySelectorAll('.content-grid').forEach(grid => {
                    grid.setAttribute('role', 'list');
                    grid.querySelectorAll('.content-card').forEach(card => {
                        card.setAttribute('role', 'listitem');
                    });
                });
            },
            
            setupReducedMotion() {
                // Check user's motion preference
                const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
                
                if (prefersReducedMotion) {
                    // Disable all animations
                    document.body.classList.add('reduced-motion');
                    
                    // Override CSS animations
                    const style = document.createElement('style');
                    style.textContent = `
                        .reduced-motion *,
                        .reduced-motion *::before,
                        .reduced-motion *::after {
                            animation-duration: 0.01ms !important;
                            animation-iteration-count: 1 !important;
                            transition-duration: 0.01ms !important;
                        }
                    `;
                    document.head.appendChild(style);
                }
            }
        };
        
        // Caching System
        const CachingSystem = {
            cacheName: 'bantu-v1',
            urlsToCache: [
                '/',
                '/index.html',
                '/styles/main.css',
                '/scripts/main.js',
                'https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Orbitron:wght@400;500;600;700&display=swap',
                'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css'
            ],
            
            async init() {
                if ('serviceWorker' in navigator && 'caches' in window) {
                    try {
                        // Register service worker
                        const registration = await navigator.serviceWorker.register('/sw.js');
                        console.log('Service Worker registered:', registration);
                        
                        // Precache critical assets
                        await this.precacheAssets();
                        
                        // Setup cache status monitoring
                        this.setupCacheMonitoring();
                        
                    } catch (error) {
                        console.log('Service Worker registration failed:', error);
                    }
                }
            },
            
            async precacheAssets() {
                try {
                    const cache = await caches.open(this.cacheName);
                    await cache.addAll(this.urlsToCache);
                    console.log('‚úÖ Assets precached');
                    this.updateCacheStatus('ready');
                } catch (error) {
                    console.log('Precaching failed:', error);
                    this.updateCacheStatus('failed');
                }
            },
            
            async cacheContent(content) {
                try {
                    const cache = await caches.open(`${this.cacheName}-content`);
                    
                    // Cache content data
                    const dataUrl = `data:application/json,${encodeURIComponent(JSON.stringify(content))}`;
                    const response = new Response(dataUrl);
                    
                    await cache.put('/cached-content', response);
                    
                    // Cache thumbnails
                    const thumbnailUrls = content.map(item => item.thumbnail_url).filter(url => url);
                    await Promise.all(
                        thumbnailUrls.map(url => 
                            cache.add(url).catch(e => console.log('Failed to cache thumbnail:', url))
                        )
                    );
                    
                    console.log('‚úÖ Content cached');
                } catch (error) {
                    console.log('Content caching failed:', error);
                }
            },
            
            async getCachedContent() {
                try {
                    const cache = await caches.open(`${this.cacheName}-content`);
                    const response = await cache.match('/cached-content');
                    
                    if (response) {
                        const data = await response.json();
                        return data;
                    }
                } catch (error) {
                    console.log('Failed to get cached content:', error);
                }
                return null;
            },
            
            updateCacheStatus(status) {
                const statusElement = document.getElementById('cache-status-text');
                if (statusElement) {
                    statusElement.textContent = `Cache: ${status}`;
                }
            },
            
            setupCacheMonitoring() {
                // Monitor cache storage
                if ('storage' in navigator && 'estimate' in navigator.storage) {
                    navigator.storage.estimate().then(estimate => {
                        const percentUsed = (estimate.usage / estimate.quota * 100).toFixed(1);
                        console.log(`Cache storage: ${percentUsed}% used`);
                        
                        if (percentUsed > 90) {
                            this.clearOldCache();
                        }
                    });
                }
                
                // Monitor online/offline status
                window.addEventListener('online', () => {
                    this.updateCacheStatus('online');
                    // Sync cached data when back online
                    this.syncCachedData();
                });
                
                window.addEventListener('offline', () => {
                    this.updateCacheStatus('offline');
                });
            },
            
            async clearOldCache() {
                try {
                    const keys = await caches.keys();
                    const currentTime = Date.now();
                    
                    for (const key of keys) {
                        if (key.includes(this.cacheName) && key !== this.cacheName) {
                            const cache = await caches.open(key);
                            const requests = await cache.keys();
                            
                            for (const request of requests) {
                                const response = await cache.match(request);
                                if (response) {
                                    const headers = response.headers;
                                    const date = headers.get('date');
                                    
                                    if (date && currentTime - new Date(date).getTime() > 7 * 24 * 60 * 60 * 1000) {
                                        await cache.delete(request);
                                    }
                                }
                            }
                        }
                    }
                    console.log('‚úÖ Old cache cleared');
                } catch (error) {
                    console.log('Failed to clear old cache:', error);
                }
            },
            
            async syncCachedData() {
                // Sync analytics events
                const queuedEvents = JSON.parse(localStorage.getItem('analytics_queue') || '[]');
                if (queuedEvents.length > 0 && window.analytics) {
                    for (const event of queuedEvents) {
                        await window.analytics.sendToSupabase(event);
                    }
                    localStorage.removeItem('analytics_queue');
                }
                
                // Sync watch history
                const watchHistory = JSON.parse(localStorage.getItem('watch_history') || '{}');
                // Send to server if needed
                
                console.log('‚úÖ Cached data synced');
            }
        };
        
        // Error Recovery System
        const ErrorRecoverySystem = {
            errors: [],
            retryQueue: [],
            
            init() {
                this.setupErrorHandling();
                this.setupNetworkMonitoring();
                this.setupRetryMechanism();
            },
            
            setupErrorHandling() {
                // Global error handler
                window.addEventListener('error', (event) => {
                    this.handleError(event.error || event);
                });
                
                // Unhandled promise rejections
                window.addEventListener('unhandledrejection', (event) => {
                    this.handleError(event.reason);
                });
                
                // Fetch errors
                const originalFetch = window.fetch;
                window.fetch = async (...args) => {
                    try {
                        return await originalFetch(...args);
                    } catch (error) {
                        this.handleError(error);
                        throw error;
                    }
                };
            },
            
            handleError(error) {
                const errorData = {
                    type: error.name || 'Error',
                    message: error.message,
                    stack: error.stack,
                    timestamp: Date.now(),
                    url: window.location.href,
                    userAgent: navigator.userAgent
                };
                
                this.errors.push(errorData);
                this.logError(errorData);
                
                // Show error to user if it's critical
                if (this.isCriticalError(error)) {
                    this.showErrorModal(error);
                }
                
                // Send to analytics
                if (window.analytics) {
                    window.analytics.track('error', errorData);
                }
            },
            
            isCriticalError(error) {
                const criticalErrors = [
                    'NetworkError',
                    'TypeError',
                    'SyntaxError',
                    'ReferenceError'
                ];
                return criticalErrors.includes(error.name) || 
                       error.message.includes('network') ||
                       error.message.includes('connection');
            },
            
            showErrorModal(error) {
                const modal = document.getElementById('error-recovery-modal');
                if (!modal) return;
                
                const message = document.getElementById('error-recovery-message');
                if (message) {
                    message.textContent = this.getUserFriendlyMessage(error);
                }
                
                modal.style.display = 'flex';
                
                // Setup retry button
                const retryBtn = document.getElementById('retry-connection');
                if (retryBtn) {
                    retryBtn.onclick = () => {
                        this.retryFailedOperations();
                        modal.style.display = 'none';
                    };
                }
                
                // Setup offline continue button
                const continueBtn = document.getElementById('continue-offline');
                if (continueBtn) {
                    continueBtn.onclick = () => {
                        this.switchToOfflineMode();
                        modal.style.display = 'none';
                    };
                }
            },
            
            getUserFriendlyMessage(error) {
                if (error.message.includes('network') || error.message.includes('connection')) {
                    return 'We\'re having trouble connecting to the server. You can continue using cached content.';
                }
                if (error.message.includes('fetch')) {
                    return 'Unable to load content. Please check your connection.';
                }
                return 'Something went wrong. Please try again.';
            },
            
            setupNetworkMonitoring() {
                window.addEventListener('online', () => {
                    this.showToast('Connection restored', 'success');
                    this.retryFailedOperations();
                });
                
                window.addEventListener('offline', () => {
                    this.showToast('You are offline. Using cached content.', 'warning');
                });
                
                // Periodic connection check
                setInterval(() => {
                    this.checkConnection();
                }, 30000);
            },
            
            async checkConnection() {
                try {
                    const response = await fetch('https://ydnxqnbjoshvxteevemc.supabase.co/rest/v1/', {
                        method: 'HEAD',
                        headers: {
                            'apikey': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlkbnhxbmJqb3Nodnh0ZWV2ZW1jIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2MzI0OTMsImV4cCI6MjA3MzIwODQ5M30.NlaCCnLPSz1mM7AFeSlfZQ78kYEKUMh_Fi-7P_ccs_U'
                        }
                    });
                    return response.ok;
                } catch {
                    return false;
                }
            },
            
            setupRetryMechanism() {
                // Auto-retry failed operations
                setInterval(() => {
                    if (navigator.onLine && this.retryQueue.length > 0) {
                        this.retryFailedOperations();
                    }
                }, 60000); // Retry every minute
            },
            
            async retryFailedOperations() {
                const queue = [...this.retryQueue];
                this.retryQueue = [];
                
                for (const operation of queue) {
                    try {
                        await operation();
                        console.log('‚úÖ Retry successful:', operation.name);
                    } catch (error) {
                        // Re-add to queue if still failing
                        this.retryQueue.push(operation);
                        console.log('‚ùå Retry failed:', operation.name);
                    }
                }
            },
            
            switchToOfflineMode() {
                // Enable offline features
                document.body.classList.add('offline-mode');
                this.showToast('Offline mode enabled', 'info');
                
                // Load cached content
                if (window.loadCachedContent) {
                    window.loadCachedContent();
                }
            },
            
            logError(error) {
                console.error('‚ùå Error:', error);
                
                // Store errors in localStorage (limited to last 50)
                const stored = JSON.parse(localStorage.getItem('error_log') || '[]');
                stored.push(error);
                if (stored.length > 50) stored.shift();
                localStorage.setItem('error_log', JSON.stringify(stored));
            },
            
            showToast(message, type = 'error') {
                // Use existing toast system
                if (window.showToast) {
                    window.showToast(message, type);
                } else {
                    console.log(`[${type.toUpperCase()}] ${message}`);
                }
            }
        };
        
        // Trending System (Real-time)
        const TrendingSystem = {
            trendingContent: [],
            updateInterval: 30000, // 30 seconds
            realtimeChannel: null,
            
            init() {
                this.loadTrendingContent();
                this.setupRealtimeUpdates();
                this.startAutoRefresh();
            },
            
            async loadTrendingContent() {
                try {
                    // Get content from last 24 hours
                    const oneDayAgo = new Date();
                    oneDayAgo.setDate(oneDayAgo.getDate() - 1);
                    
                    const content = await contentSupabase.query('Content', {
                        select: '*',
                        where: { 
                            status: 'published',
                            created_at: `gte.${oneDayAgo.toISOString()}`
                        },
                        orderBy: 'views',
                        order: 'desc',
                        limit: 10
                    });
                    
                    // Calculate trending score (views + likes*2 in last hour)
                    this.trendingContent = content.map(item => ({
                        ...item,
                        trendingScore: this.calculateTrendingScore(item)
                    })).sort((a, b) => b.trendingScore - a.trendingScore);
                    
                    this.updateTrendingSection();
                    
                } catch (error) {
                    console.error('Failed to load trending content:', error);
                    // Use cached trending data
                    const cached = localStorage.getItem('trending_content');
                    if (cached) {
                        this.trendingContent = JSON.parse(cached);
                        this.updateTrendingSection();
                    }
                }
            },
            
            calculateTrendingScore(item) {
                // Base score from views and likes
                let score = (item.views || 0) + ((item.likes || 0) * 2);
                
                // Recency boost (content from last hour gets boost)
                const created = new Date(item.created_at);
                const hoursAgo = (Date.now() - created.getTime()) / (1000 * 60 * 60);
                if (hoursAgo < 1) score *= 1.5;
                if (hoursAgo < 0.25) score *= 2; // Last 15 minutes
                
                // Engagement rate boost
                if (item.views > 100) {
                    const engagementRate = (item.likes || 0) / item.views;
                    if (engagementRate > 0.1) score *= 1.2; // High engagement
                }
                
                return Math.round(score);
            },
            
            setupRealtimeUpdates() {
                // Setup Supabase Realtime for trending updates
                console.log('üì° Setting up real-time trending updates...');
                
                // Simulate real-time updates
                setInterval(() => {
                    this.simulateTrendingUpdate();
                }, this.updateInterval);
            },
            
            simulateTrendingUpdate() {
                // Randomly update trending scores
                this.trendingContent = this.trendingContent.map(item => ({
                    ...item,
                    trendingScore: item.trendingScore + Math.floor(Math.random() * 10),
                    views: item.views + Math.floor(Math.random() * 5)
                })).sort((a, b) => b.trendingScore - a.trendingScore);
                
                this.updateTrendingSection();
                
                // Save to cache
                localStorage.setItem('trending_content', JSON.stringify(this.trendingContent));
            },
            
            updateTrendingSection() {
                const trendingSection = document.querySelector('.section[data-type="trending"]');
                if (!trendingSection) return;
                
                const grid = trendingSection.querySelector('.content-grid');
                if (!grid) return;
                
                // Take top 5 trending items
                const topTrending = this.trendingContent.slice(0, 5);
                
                grid.innerHTML = topTrending.map(item => this.createTrendingCard(item)).join('');
                
                // Setup event listeners for new cards
                this.setupTrendingCardListeners(grid);
                
                // Update "Trending Now" badge with live indicator
                const badge = trendingSection.querySelector('.trending-badge');
                if (badge) {
                    badge.innerHTML = `<i class="fas fa-fire"></i> Live Trending ‚Ä¢ Updated ${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
                }
            },
            
            createTrendingCard(item) {
                return `
                    <div class="content-card trending-card" data-content-id="${item.id}">
                        <div class="card-thumbnail">
                            <img src="${item.thumbnail_url || 'https://images.unsplash.com/photo-1511379938547-c1f69419868d?w=400&h=225&fit=crop'}" 
                                 alt="${item.title}"
                                 loading="lazy"
                                 onerror="this.src='https://images.unsplash.com/photo-1511379938547-c1f69419868d?w=400&h=225&fit=crop'">
                            <div class="thumbnail-overlay"></div>
                            <div class="trending-badge">üî• Trending #${this.trendingContent.findIndex(c => c.id === item.id) + 1}</div>
                            <div class="video-preview-container">
                                <video class="video-preview" muted preload="metadata">
                                    <source src="${item.file_url || ''}" type="video/mp4">
                                </video>
                            </div>
                            <button class="share-btn" title="Share" data-content-id="${item.id}">
                                <i class="fas fa-share"></i>
                            </button>
                        </div>
                        <div class="card-content">
                            <h3 class="card-title" title="${item.title}">
                                ${item.title.length > 50 ? item.title.substring(0, 50) + '...' : item.title}
                            </h3>
                            <div class="card-stats">
                                <span class="stat">
                                    <i class="fas fa-eye"></i> ${this.formatNumber(item.views || 0)}
                                </span>
                                <span class="stat">
                                    <i class="fas fa-heart"></i> ${this.formatNumber(item.likes || 0)}
                                </span>
                                <span class="stat">
                                    <i class="fas fa-fire"></i> ${this.formatNumber(item.trendingScore)}
                                </span>
                            </div>
                            <button class="creator-btn" 
                                    data-creator-id="${item.creator_id}"
                                    data-creator-name="${item.creator}">
                                <i class="fas fa-user"></i>
                                ${item.creator.length > 15 ? item.creator.substring(0, 15) + '...' : item.creator}
                            </button>
                        </div>
                    </div>
                `;
            },
            
            setupTrendingCardListeners(grid) {
                grid.querySelectorAll('.content-card').forEach(card => {
                    card.addEventListener('click', (e) => {
                        if (e.target.closest('.share-btn') || e.target.closest('.creator-btn')) {
                            return;
                        }
                        
                        const contentId = card.dataset.contentId;
                        if (contentId) {
                            window.location.href = `content-detail.html?id=${contentId}`;
                        }
                    });
                });
            },
            
            formatNumber(num) {
                if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
                if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
                return num.toString();
            },
            
            startAutoRefresh() {
                // Refresh trending content every 5 minutes
                setInterval(() => {
                    this.loadTrendingContent();
                }, 5 * 60 * 1000);
            }
        };
        
        // Enhanced Video Preview System
        const EnhancedVideoPreviewSystem = {
            hoverTimeout: null,
            currentPreview: null,
            previewQueue: [],
            maxConcurrentPreviews: 2,
            
            init() {
                this.setupEventDelegation();
                this.setupIntersectionObserver();
                this.setupVideoPreloading();
            },
            
            setupEventDelegation() {
                // Mouse events
                document.addEventListener('mouseover', (e) => {
                    const card = e.target.closest('.content-card');
                    if (card && !card.classList.contains('video-hover')) {
                        this.handleCardHover(card);
                    }
                }, { passive: true });
                
                document.addEventListener('mouseout', (e) => {
                    const card = e.target.closest('.content-card');
                    if (card && card.classList.contains('video-hover')) {
                        this.handleCardLeave(card);
                    }
                }, { passive: true });
                
                // Touch events for mobile
                document.addEventListener('touchstart', (e) => {
                    const card = e.target.closest('.content-card');
                    if (card) {
                        e.preventDefault();
                        this.handleCardHover(card);
                    }
                }, { passive: false });
                
                document.addEventListener('touchend', (e) => {
                    const card = e.target.closest('.content-card');
                    if (card && card.classList.contains('video-hover')) {
                        this.handleCardLeave(card);
                    }
                }, { passive: true });
                
                // Keyboard navigation support
                document.addEventListener('focusin', (e) => {
                    const card = e.target.closest('.content-card');
                    if (card && !card.classList.contains('video-hover')) {
                        this.handleCardHover(card);
                    }
                });
                
                document.addEventListener('focusout', (e) => {
                    const card = e.target.closest('.content-card');
                    if (card && card.classList.contains('video-hover')) {
                        this.handleCardLeave(card);
                    }
                });
            },
            
            handleCardHover(card) {
                clearTimeout(this.hoverTimeout);
                
                this.hoverTimeout = setTimeout(() => {
                    const videoElement = card.querySelector('.video-preview');
                    if (videoElement && videoElement.src) {
                        card.classList.add('video-hover');
                        this.currentPreview = videoElement;
                        
                        // Add to preview queue
                        this.addToPreviewQueue(videoElement);
                        
                        // Play video preview
                        this.playVideoPreview(videoElement);
                    }
                }, 300); // Reduced delay for better UX
            },
            
            handleCardLeave(card) {
                clearTimeout(this.hoverTimeout);
                
                const videoElement = card.querySelector('.video-preview');
                if (videoElement) {
                    this.pauseVideoPreview(videoElement);
                    this.removeFromPreviewQueue(videoElement);
                }
                
                card.classList.remove('video-hover');
                this.currentPreview = null;
            },
            
            addToPreviewQueue(videoElement) {
                this.previewQueue.push(videoElement);
                if (this.previewQueue.length > this.maxConcurrentPreviews) {
                    const oldVideo = this.previewQueue.shift();
                    if (oldVideo && !oldVideo.paused) {
                        oldVideo.pause();
                        oldVideo.currentTime = 0;
                    }
                }
            },
            
            removeFromPreviewQueue(videoElement) {
                const index = this.previewQueue.indexOf(videoElement);
                if (index > -1) {
                    this.previewQueue.splice(index, 1);
                }
            },
            
            async playVideoPreview(videoElement) {
                try {
                    // Set video quality based on connection
                    if (navigator.connection) {
                        const connection = navigator.connection;
                        if (connection.saveData || connection.effectiveType === 'slow-2g') {
                            videoElement.preload = 'metadata';
                        } else {
                            videoElement.preload = 'auto';
                        }
                    }
                    
                    videoElement.currentTime = 0;
                    await videoElement.play();
                    
                    // Analytics tracking
                    if (window.analytics) {
                        const contentId = videoElement.closest('.content-card')?.dataset.contentId;
                        if (contentId) {
                            window.analytics.trackContentInteraction(contentId, 'video_preview_play');
                        }
                    }
                    
                } catch (error) {
                    console.log('Video autoplay prevented:', error);
                    videoElement.closest('.content-card')?.classList.remove('video-hover');
                }
            },
            
            pauseVideoPreview(videoElement) {
                if (!videoElement.paused) {
                    videoElement.pause();
                    videoElement.currentTime = 0;
                }
            },
            
            setupIntersectionObserver() {
                // Lazy load video elements when they come into view
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const video = entry.target;
                            if (video.dataset.src && !video.src) {
                                video.src = video.dataset.src;
                                delete video.dataset.src;
                            }
                        }
                    });
                }, { rootMargin: '50px' });
                
                // Observe all video elements
                document.querySelectorAll('.video-preview').forEach(video => {
                    observer.observe(video);
                });
            },
            
            setupVideoPreloading() {
                // Preload first few videos for better UX
                const firstCards = document.querySelectorAll('.content-card:nth-child(-n+3)');
                firstCards.forEach(card => {
                    const video = card.querySelector('.video-preview');
                    if (video) {
                        video.preload = 'metadata';
                    }
                });
            },
            
            pauseAllPreviews() {
                this.previewQueue.forEach(video => {
                    if (!video.paused) {
                        video.pause();
                        video.currentTime = 0;
                    }
                });
                this.previewQueue = [];
                
                document.querySelectorAll('.video-preview').forEach(video => {
                    if (!video.paused) {
                        video.pause();
                        video.currentTime = 0;
                    }
                });
                
                document.querySelectorAll('.video-hover').forEach(card => {
                    card.classList.remove('video-hover');
                });
                
                this.currentPreview = null;
            }
        };
        
        // Enhanced Continue Watching System
        const EnhancedContinueWatchingSystem = {
            watchHistory: {},
            continueWatchingThreshold: 10, // Minimum 10% watched
            maxContinueWatchingItems: 10,
            
            init() {
                this.loadWatchHistory();
                this.setupVideoProgressTracking();
                this.setupRealtimeSync();
            },
            
            loadWatchHistory() {
                try {
                    const history = localStorage.getItem('watch_history');
                    if (history) {
                        this.watchHistory = JSON.parse(history);
                    }
                    
                    // Clean up old entries (older than 30 days)
                    const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
                    Object.keys(this.watchHistory).forEach(contentId => {
                        const entry = this.watchHistory[contentId];
                        if (entry.lastWatched < thirtyDaysAgo) {
                            delete this.watchHistory[contentId];
                        }
                    });
                    
                    this.saveWatchHistory();
                    
                } catch (error) {
                    console.error('Error loading watch history:', error);
                    this.watchHistory = {};
                }
            },
            
            saveWatchHistory() {
                try {
                    localStorage.setItem('watch_history', JSON.stringify(this.watchHistory));
                    
                    // Sync with server if online
                    if (navigator.onLine) {
                        this.syncWithServer();
                    }
                    
                } catch (error) {
                    console.error('Error saving watch history:', error);
                }
            },
            
            async syncWithServer() {
                // This would sync with your backend
                // Placeholder for implementation
            },
            
            updateWatchProgress(contentId, progress, duration = null) {
                if (progress < this.continueWatchingThreshold) {
                    // Don't track if not enough progress
                    return;
                }
                
                this.watchHistory[contentId] = {
                    progress: Math.min(progress, 95), // Cap at 95% to always show "continue"
                    lastWatched: Date.now(),
                    duration: duration,
                    lastPosition: progress
                };
                
                this.saveWatchHistory();
                
                // Also save progress for progress bars
                localStorage.setItem(`watch_progress_${contentId}`, progress.toString());
                
                // Update UI
                this.updateContinueWatchingSection();
                
                // Analytics
                if (window.analytics) {
                    window.analytics.trackWatchTime(contentId, duration || 0);
                }
            },
            
            getContinueWatchingContent(allContent) {
                const continueWatching = [];
                
                for (const [contentId, data] of Object.entries(this.watchHistory)) {
                    if (data.progress >= this.continueWatchingThreshold && data.progress < 95) {
                        const content = allContent.find(c => c.id == contentId);
                        if (content) {
                            continueWatching.push({
                                ...content,
                                watchProgress: data.progress,
                                lastWatched: data.lastWatched,
                                lastPosition: data.lastPosition,
                                duration: data.duration
                            });
                        }
                    }
                }
                
                // Sort by most recently watched and limit
                return continueWatching
                    .sort((a, b) => b.lastWatched - a.lastWatched)
                    .slice(0, this.maxContinueWatchingItems);
            },
            
            setupVideoProgressTracking() {
                // Listen for video play events
                document.addEventListener('play', (e) => {
                    if (e.target.tagName === 'VIDEO') {
                        const video = e.target;
                        const contentId = video.closest('.content-card')?.dataset.contentId;
                        
                        if (contentId) {
                            // Start tracking progress for this video
                            this.startProgressTracking(video, contentId);
                        }
                    }
                }, true);
            },
            
            startProgressTracking(video, contentId) {
                let lastReportedProgress = 0;
                
                const progressHandler = () => {
                    if (video.duration) {
                        const progress = (video.currentTime / video.duration) * 100;
                        
                        // Only update if significant progress (5% or more)
                        if (Math.abs(progress - lastReportedProgress) >= 5) {
                            this.updateWatchProgress(contentId, progress, video.duration);
                            lastReportedProgress = progress;
                        }
                    }
                };
                
                // Track every 5 seconds
                const progressInterval = setInterval(progressHandler, 5000);
                
                // Track on pause/end
                video.addEventListener('pause', () => {
                    progressHandler();
                });
                
                video.addEventListener('ended', () => {
                    progressHandler();
                    clearInterval(progressInterval);
                });
                
                // Clean up interval when video stops
                video.addEventListener('abort', () => clearInterval(progressInterval));
                video.addEventListener('error', () => clearInterval(progressInterval));
            },
            
            setupRealtimeSync() {
                // Sync watch history across devices
                window.addEventListener('storage', (e) => {
                    if (e.key === 'watch_history') {
                        this.loadWatchHistory();
                        this.updateContinueWatchingSection();
                    }
                });
            },
            
            updateContinueWatchingSection() {
                // This would update the UI section
                // Implementation depends on your UI structure
            },
            
            getWatchProgress(contentId) {
                const entry = this.watchHistory[contentId];
                return entry ? entry.progress : 0;
            },
            
            getResumeTime(contentId) {
                const entry = this.watchHistory[contentId];
                if (entry && entry.duration && entry.lastPosition) {
                    return (entry.lastPosition / 100) * entry.duration;
                }
                return 0;
            },
            
            clearHistory() {
                this.watchHistory = {};
                this.saveWatchHistory();
                this.updateContinueWatchingSection();
            }
        };
        
        // Content Statistics System (Likes and Views)
        const ContentStatsSystem = {
            init() {
                this.setupStatsDisplay();
                this.setupStatsTracking();
                this.setupRealtimeUpdates();
            },
            
            setupStatsDisplay() {
                // Ensure all content cards show likes and views
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        if (mutation.type === 'childList') {
                            mutation.addedNodes.forEach(node => {
                                if (node.nodeType === 1 && node.classList?.contains('content-card')) {
                                    this.addStatsToCard(node);
                                }
                            });
                        }
                    });
                });
                
                observer.observe(document.body, {
                    childList: true,
                    subtree: true
                });
                
                // Process existing cards
                document.querySelectorAll('.content-card:not(.stats-added)').forEach(card => {
                    this.addStatsToCard(card);
                });
            },
            
            addStatsToCard(card) {
                if (card.classList.contains('stats-added')) return;
                
                const contentId = card.dataset.contentId;
                if (!contentId) return;
                
                // Get stats from data attributes or localStorage
                const views = card.dataset.views || localStorage.getItem(`views_${contentId}`) || 0;
                const likes = card.dataset.likes || localStorage.getItem(`likes_${contentId}`) || 0;
                
                // Create or update stats element
                let statsElement = card.querySelector('.card-stats');
                if (!statsElement) {
                    statsElement = document.createElement('div');
                    statsElement.className = 'card-stats';
                    
                    // Insert before creator button
                    const creatorBtn = card.querySelector('.creator-btn');
                    if (creatorBtn) {
                        card.insertBefore(statsElement, creatorBtn);
                    } else {
                        card.querySelector('.card-content')?.appendChild(statsElement);
                    }
                }
                
                statsElement.innerHTML = `
                    <span class="stat" title="Views">
                        <i class="fas fa-eye"></i> ${this.formatNumber(views)}
                    </span>
                    <span class="stat" title="Likes">
                        <i class="fas fa-heart"></i> ${this.formatNumber(likes)}
                    </span>
                    ${card.dataset.trendingScore ? `
                    <span class="stat" title="Trending Score">
                        <i class="fas fa-fire"></i> ${this.formatNumber(card.dataset.trendingScore)}
                    </span>
                    ` : ''}
                `;
                
                card.classList.add('stats-added');
            },
            
            setupStatsTracking() {
                // Track view counts
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const card = entry.target;
                            const contentId = card.dataset.contentId;
                            
                            if (contentId && !card.dataset.viewTracked) {
                                this.trackView(contentId);
                                card.dataset.viewTracked = true;
                            }
                        }
                    });
                }, { threshold: 0.5 });
                
                // Observe all content cards
                document.querySelectorAll('.content-card').forEach(card => {
                    observer.observe(card);
                });
                
                // Track likes
                document.addEventListener('click', (e) => {
                    const likeBtn = e.target.closest('.like-btn');
                    if (likeBtn) {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const contentId = likeBtn.dataset.contentId;
                        if (contentId) {
                            this.trackLike(contentId);
                        }
                    }
                });
            },
            
            async trackView(contentId) {
                // Increment local view count
                const currentViews = parseInt(localStorage.getItem(`views_${contentId}`) || '0');
                localStorage.setItem(`views_${contentId}`, (currentViews + 1).toString());
                
                // Update UI
                const cards = document.querySelectorAll(`[data-content-id="${contentId}"]`);
                cards.forEach(card => {
                    const viewsElement = card.querySelector('.stat:nth-child(1)');
                    if (viewsElement) {
                        const newViews = currentViews + 1;
                        viewsElement.innerHTML = `<i class="fas fa-eye"></i> ${this.formatNumber(newViews)}`;
                    }
                });
                
                // Send to analytics
                if (window.analytics) {
                    window.analytics.trackContentInteraction(contentId, 'view');
                }
                
                // Sync with server (if online)
                if (navigator.onLine) {
                    try {
                        // This would be your API call to update view count
                        // await updateContentViewCount(contentId);
                    } catch (error) {
                        console.error('Failed to sync view count:', error);
                    }
                }
            },
            
            async trackLike(contentId) {
                // Toggle like status
                const liked = localStorage.getItem(`liked_${contentId}`) === 'true';
                const newLiked = !liked;
                
                localStorage.setItem(`liked_${contentId}`, newLiked.toString());
                
                // Update like count
                const currentLikes = parseInt(localStorage.getItem(`likes_${contentId}`) || '0');
                const newLikes = newLiked ? currentLikes + 1 : Math.max(0, currentLikes - 1);
                localStorage.setItem(`likes_${contentId}`, newLikes.toString());
                
                // Update UI
                const cards = document.querySelectorAll(`[data-content-id="${contentId}"]`);
                cards.forEach(card => {
                    // Update like button
                    const likeBtn = card.querySelector('.like-btn');
                    if (likeBtn) {
                        likeBtn.classList.toggle('liked', newLiked);
                        likeBtn.innerHTML = newLiked ? 
                            '<i class="fas fa-heart"></i> Liked' : 
                            '<i class="far fa-heart"></i> Like';
                    }
                    
                    // Update like count display
                    const likesElement = card.querySelector('.stat:nth-child(2)');
                    if (likesElement) {
                        likesElement.innerHTML = `<i class="fas fa-heart"></i> ${this.formatNumber(newLikes)}`;
                    }
                });
                
                // Send to analytics
                if (window.analytics) {
                    window.analytics.trackContentInteraction(contentId, newLiked ? 'like' : 'unlike');
                }
                
                // Sync with server (if online)
                if (navigator.onLine) {
                    try {
                        // This would be your API call to update like
                        // await updateContentLike(contentId, newLiked);
                    } catch (error) {
                        console.error('Failed to sync like:', error);
                    }
                }
            },
            
            setupRealtimeUpdates() {
                // Listen for real-time updates from server
                // This would use WebSockets or Supabase Realtime
                setInterval(() => {
                    this.simulateRealtimeStatsUpdate();
                }, 10000); // Every 10 seconds
            },
            
            simulateRealtimeStatsUpdate() {
                // Randomly update some stats for demo
                document.querySelectorAll('.content-card').forEach(card => {
                    if (Math.random() > 0.8) { // 20% chance
                        const contentId = card.dataset.contentId;
                        if (contentId) {
                            // Randomly increase views
                            const currentViews = parseInt(localStorage.getItem(`views_${contentId}`) || '0');
                            const newViews = currentViews + Math.floor(Math.random() * 3);
                            localStorage.setItem(`views_${contentId}`, newViews.toString());
                            
                            // Update UI
                            const viewsElement = card.querySelector('.stat:nth-child(1)');
                            if (viewsElement) {
                                viewsElement.innerHTML = `<i class="fas fa-eye"></i> ${this.formatNumber(newViews)}`;
                            }
                        }
                    }
                });
            },
            
            formatNumber(num) {
                const n = parseInt(num);
                if (isNaN(n)) return '0';
                if (n >= 1000000) return (n / 1000000).toFixed(1) + 'M';
                if (n >= 1000) return (n / 1000).toFixed(1) + 'K';
                return n.toString();
            }
        };
        
        // Main initialization
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('üöÄ Bantu Stream Connect Enhanced Home Feed Initializing...');
            
            // Start performance monitoring immediately
            PerformanceMonitor.init();
            
            // Load deferred CSS
            const deferredStyles = document.getElementById('deferred-styles');
            if (deferredStyles) {
                deferredStyles.href = "data:text/css," + encodeURIComponent(`
                    /* Non-critical styles go here */
                    ${document.querySelector('style').textContent.split('/* Critical CSS for FCP */')[1]}
                `);
            }
            
            // Initialize all systems
            ThemeSystem.init();
            AccessibilitySystem.init();
            AnalyticsSystem.init();
            NotificationSystem.init();
            CachingSystem.init();
            ErrorRecoverySystem.init();
            EnhancedVideoPreviewSystem.init();
            EnhancedContinueWatchingSystem.init();
            ContentStatsSystem.init();
            
            // Initialize global objects
            window.analytics = AnalyticsSystem;
            window.notifications = NotificationSystem;
            window.trendingSystem = new TrendingSystem();
            
            // Rest of your initialization code...
            // [Your existing initialization code continues here]
            
            // Start trending system after content loads
            setTimeout(() => {
                window.trendingSystem.init();
            }, 2000);
            
            // Performance optimization: Preload critical images
            const preloadImages = [
                'https://images.unsplash.com/photo-1511379938547-c1f69419868d?w=400&h=225&fit=crop'
            ];
            
            preloadImages.forEach(src => {
                const img = new Image();
                img.src = src;
            });
        });
    </script>
    
    <!-- Service Worker Registration -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js').then(registration => {
                    console.log('ServiceWorker registration successful');
                }).catch(err => {
                    console.log('ServiceWorker registration failed: ', err);
                });
            });
        }
    </script>
    
    <!-- Service Worker Script (sw.js content would be separate) -->
    <script id="sw-script" type="text/javascript">
        // This would be your actual service worker file
        // For now, we'll include a basic version
        const CACHE_NAME = 'bantu-stream-connect-v1';
        const urlsToCache = [
            '/',
            '/index.html',
            '/styles/main.css',
            '/scripts/main.js'
        ];

        self.addEventListener('install', event => {
            event.waitUntil(
                caches.open(CACHE_NAME)
                    .then(cache => cache.addAll(urlsToCache))
            );
        });

        self.addEventListener('fetch', event => {
            event.respondWith(
                caches.match(event.request)
                    .then(response => response || fetch(event.request))
            );
        });
    </script>
</body>
</html>
